{
  "hash": "e225067390fe21f3de7627e7d94b46bb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Remote sensing\"\neditor_options: \n  chunk_output_type: console\nauthor: \n  name: Ivan Alberto Lizarazo\n  email: ializarazos@unal.edu.co \n  affiliations:\n    name: Universidad Nacional de Colombia\n    city: Bogotá\n---\n\n\n\n\n\n\n\n\n## Introduction\n\nRemote sensing techniques, in the sense of gathering & processing of data by a device separated from the object under study, are increasingly providing an important component of the set of technologies available for the study of vegetation systems and their functioning. This is in spite that many applications only provide indirect estimations of the biophysical variables of interest [@jones2010remote].\n\nParticular advantages of remote sensing for vegetation studies are that: (i) it is non-contact and non-destructive; and (ii) observations are easily extrapolated to larger scales. Even at the plant scale, remotely sensed imagery is advantageous as it allows rapid sampling of large number of plants [@jones2010remote].\n\nThis chapter aims at providing a conceptual & practical approach to apply remote sensing data and techniques to infer information useful for monitoring crop diseases. The structure of this chapter is divided into four sections. The first one introduces basic remote sensing concepts and provides a summary of applications of remote sensing of crop diseases. The second one illustrates a case study focused on identification of banana Fusarium wilt from multispectral UAV imagery. The third one illustrates a case study dealing with estimation of cercospora leaf spot disease on table beet. Finally, it concludes with several reflections about potential and limitations of this technology.\n\n## Remote sensing background\n\n### Optical remote sensing\n\nOptical remote sensing makes use of the radiation reflected by a surface in the visible (\\~400-700 nm), the near infrared (700-1300 nm) and shortwave infrared (1300-\\~3000 nm) parts of the electromagnetic spectrum. Spaceborne & airborne-based remote sensing and field spectroscopy utilize the solar radiation as an illumination source. Lab spectroscopy utilizes a lamp as an artificial illumination source [@fig-RS1].\n\n![Optical remote sensing via spaceborne sensors, field spectroscopy and laboratory spectroscopy (Adapted from [https://pages.cms.hu-berlin.de/EOL/geo_rs/index.htm](https://pages.cms.hu-berlin.de/EOL/geo_rs/)) .](imgs/RS1.png){#fig-RS1}\n\nThe proportion of the radiation reflected by a surface depends on the surface's spectral reflection, absorption and transmission properties and varies with wavelength [@fig-RS2]. These spectral properties in turn depend on the surface's physical and chemical constituents [@fig-RS2]. Measuring the reflected radiation hence allows us to draw conclusions on a surface's characteristic, which is the basic principle behind optical remote sensing.\n\n![Reflection, absortion and transmission by a surface (left). Spectral reflectance profile of a vegetation with major factors determining the reflection (right). Source: <https://pages.cms.hu-berlin.de/EOL/geo_rs/>](imgs/RS-2.jpg){#fig-RS2}\n\n### Vegetation spectral properties\n\nOptical remote sensing enables the deduction of various vegetation-related characteristics, including biochemical properties (e.g., pigments, water content), structural properties (e.g., leaf area index (LAI), biomass) or process properties (e.g., light use efficiency (LUE)). The ability to deduce these characteristics depends on the ability of a sensor to resolve vegetation spectra. Hyperspectral sensors capture spectral information in hundreds of narrow and contiguous bands in the VIS, NIR and SWIR, and, thus, resolve subtle absorption features caused by specific vegetation constituents (e.g. anthocyanins, carotenoids, lignin, cellulose, proteins). In contrast, multispectral sensors capture spectral information in a few broad spectral bands and, thus, only resolve broader spectral features. Still, multispectral systems like Sentinel-2 have been demonstrated to be useful to derive valuable vegetation properties (e.g., LAI, chlorophyll).\n\n![Vegetation spectrum in hyperspectral (ASD FielSpec4, EnMAP) and multispectral (Sentinel-2) resolution as well as characteristic spectral features caused by various constituents and processes (absorption lines shown as grey dashed lines). Source: [@hank2018]](imgs/RS-3.png){#fig-RS3}\n\n### What measures a remote sensor?\n\nOptical sensors/spectrometers measure the radiation reflected by a surface to a certain solid angle in the physical quantity radiance. The unit of radiance is watts per square meter per steradian (W • m-2 • sr-1) [@fig-RS4]. In other words, radiance describes the amount of energy (W) that is reflected from a surface (m-2) and arrives at the sensor in a three-dimensional angle (sr-1).\n\n![Source: https://pages.cms.hu-berlin.de/EOL/geo_rs/](imgs/RS-4.png){#fig-RS4 fig-align=\"center\" width=\"428\"}\n\nA general problem related to the use of radiance as unit of measurement is the variation of radiance values with illumination. For example, the absolute incoming solar radiation varies over the course of the day as a function of the relative position between sun and surface and so does the absolute amount of radiance measured. We can only compare measurements taken a few hours apart or on different dates when we are putting the measured radiance in relation to the incoming illumination.\n\nThe quotient between measured reflected radiance and measured incoming radiance (Radiance~reflected~ / Radiance~incoming~) is called reflectance (usually denoted as $\\rho$). Reflectance provides a stable unit of measurement which is independent from illumination and is the percentage of the total measurable radiation, which has not been absorbed or transmitted.\n\n### Hyperspectral vs.multispectral imagery\n\nHyperspectral imaging involves capturing and analyzing data from a large number of narrow, contiguous bands across the electromagnetic spectrum, resulting in a high-resolution spectrum for each pixel in the image. As a result, a hyperspectral camera provides smooth spectra. The spectra provided by multispectral cameras are more like stairs or saw teeth without the ability to depict acute spectral signatures [@fig-RS8].\n\n### Vegetation Indices\n\nA vegetation index (VI) represents a spectral transformation of two or more bands of spectral imagery into a singleband image. A VI is designed to enhance the vegetation signal with regard to different vegetation properties, while minimizing confounding factors such as soil background reflectance, directional, or atmospheric effects. There are many different VIs, including multispectral broadband indices as well as hyperspectral narrowband indices.\n\nMost of the multispectral broadband indices make use of the inverse relationship between the lower reflectance in the red (through chlorophyll absorption) and higher reflectance in the near-infrared (through leaf structure) to provide a measure of greenness that can be indirectly related to biochemical or structural vegetation properties (e.g., chlorophyll content, LAI). The Normalized Difference Vegetation Index (NDVI) is one of the most commonly used broadband VIs:\n\n$$NDVI = \\frac{\\rho_{nir} - \\rho_{red} }{\\rho_{nir} + \\rho_{red}}$$\n\nThe interpretation of the absolute value of the NDVI is highly informative, as it allows the immediate recognition of the areas of the farm or field that have problems. The NDVI is a simple index to interpret: its values vary between -1 and 1, and each value corresponds to a different agronomic situation, regardless of the crop [@fig-RS6]\n\n![Agronomic conditions depending on the values in a NDVI scale](imgs/RS-6.png){#fig-RS6 fig-align=\"center\"}\n\n## Remote sensing of crop diseases\n\n### Detection of plant stress\n\nOne popular use of remote sensing is in diagnosis and monitoring of plant *responses* to biotic (i.e. disease and insect damage) and abiotic stress (e.g. water stress, heat, high light, pollutants) with hundreds of publications on the topic. It is worth nothing that most available techniques monitor the plant *response* rather than the stress itself. For example, with some diseases, it is common to estimate changes in canopy cover (using vegetation indices) as measures of \"disease\" but this measure could also be associated to water deficit [@jones2010remote]. This highlights the importance of measuring crop conditions in the field & laboratory to collect reliable data and be able to disentangle complex plant responses. Anyway, remote sensing can be used as the first step in site-specific disease control and also to phenotype the reactions of plant genotypes to pathogen attack [@lowe2017].\n\n### Optical methods for measuring crop disease\n\nThere are a variety of optical sensors for the assessment of plant diseases. Sensors can be based only on the visible spectrum (400-700 nm) or on the visible and/or infrared spectrum (700 nm - 1mm). The latter may include near-infrared (NIR) (0.75-1.4 $μm$), short wavelength infrared (SWIR) (1.4--3 $μm$), medium wavelength infrared (MWIR) (3-8 $μm$), or thermal infrared (8-15 $μm$) [@fig-RS8]. Sensors record either imaging or non imaging (i.e average) spectral radiance values which need to be converted to reflectance before conducting any crop disease monitoring task.\n\n![source: @delponte2024](imgs/RS-8.png){#fig-RS8}\n\nIn a recent chapter of Agrio's Plant Pathology, @delponte2024 highlights the importance of understanding the basic principles of the interaction of light with plant tissue or the plant canopy as a crucial prerrequisite for the analysis and interpretation for disease assessment. When a plant is infected, there are changes to the phisiology and biochemistry of the host, with the eventual development of disease symptoms and/or signs of the pathogen which may be accompanied by structural and biochemical changes that affect absorbance, transmittance, and reflectance of light [@fig-RS10].\n\n![source: @delponte2024](imgs/RS-10.png){#fig-RS9}\n\n### Scopes of disease sensing\n\nThe quantification of typical disease symptoms (disease severity) and assessment of leaves infected by several pathogens are relatively simple for imaging systems but may become a challenge for nonimaging sensors and sensors with inadequate spatial resolution [@oerke2020]. Systematic monitoring of a crop by remote sensors can allow farmers to take preventive actions if infections are detected early.  Remote sensing sensors & processing techniques need to be carefully selected to be capable of (a) detecting a deviation in the crop's health status brought about by pathogens, (b) identifying the disease, and (c) quantifying the severity of the disease.  Remote sensing can also be effectively used in (d) food quality control [@fig-RS10].\n\n![Source: [@oerke2020]](imgs/RS-9.png){#fig-RS10}\n\n### Monitoring plant diseases\n\nSensing of plants for precision disease control is done in large fields or greenhouses where the aim is to detect the occurrence of diseases at the early stages of epidemics, i.e., at low symptom frequency. @lowe2017 reviewed hyperspectral imaging of plant diseases, focusing on early detection of diseases for crop monitoring. They report several analysis techniques successfully used for the detection of biotic and abiotic stresses with reported levels of accuracy higher than 80%.\n\n| Technique                              | Plant (stress)                  |\n|----------------------------------------|---------------------------------|\n| Quadratic discriminant analysis (QDA)  | Wheat (yellow rust)             |\n|                                        | Avacado (laurel wilt)           |\n| Decision tree (DT)                     | Avacado (laurel wilt)           |\n|                                        | Sugarbeet (cerospora leaf spot) |\n|                                        | Sugarbeet (powdery mildew)      |\n|                                        | Sugarbeet (leaf rust)           |\n| Multilayer perceptron (MLP)            | Wheat (yellow rust)             |\n| Partial least square regression (PLSR) | Celery (sclerotinia rot)        |\n| Raw                                    |                                 |\n| Savitsky-Golay 1st derivative          |                                 |\n| Savitsky-Golay 2nd derivative          |                                 |\n| Partial least square regression (PLSR) | Wheat (yellow rust)             |\n| Fishers linear determinant analysis    | Wheat (aphid)                   |\n|                                        | Wheat (powdery mildew)          |\n|                                        | Wheat (powdery mildew)          |\n| Erosion and dilation                   | Cucumber (downey mildew)        |\n| Spectral angle mapper (SAM)            | Sugarbeet (cerospora leaf spot) |\n|                                        | Sugarbeet (powdery mildew)      |\n|                                        | Sugarbeet (leaf rust)           |\n|                                        | Wheat (head blight)             |\n| Artificial neural network (ANN)        | Sugarbeet (cerospora leaf spot) |\n|                                        | Sugarbeet (powdery mildew)      |\n|                                        | Sugarbeet (leaf rust)           |\n| Support vector machine (SVM)           | Sugarbeet (cerospora leaf spot) |\n|                                        | Sugarbeet (powdery mildew)      |\n|                                        | Sugarbeet (leaf rust)           |\n|                                        | Barley (drought)                |\n| Spectral information divergence (SID)  | Grapefruit                      |\n|                                        | (canker, greasy spot, insect    |\n|                                        | damage, scab, wind scar)        |\n\n: Statistical techniques used to detect both biotic and abiotic stresses in crops. Source: @lowe2017\n\n@lowe2017 state that remote sensing of diseases under production conditions is challenging because of variable environmental factors and crop-intrinsic characteristics, e.g., 3D architecture, various growth stages, variety of diseases that may occur simultaneously, and the high sensitivity required to reliably perceive low disease levels suitable for decision-making in disease control. The use of less sensitive systems may be restricted to the assessment of crop damage and yield losses due to diseases.\n\n### UAV applications for plant disease detection and monitoring\n\n@kouadio2023 undertook a systematic quantitative literature review to summarize existing literature in UAV-based applications for plant disease detection and monitoring. Results reveal a global disparity in research on the topic, with Asian countries being the top contributing countries. World regions such as Oceania and Africa exhibit comparatively lesser representation. To date, research has largely focused on diseases affecting wheat, sugar beet, potato, maize, and grapevine [@fig-RS11]. Multispectral, red-green-blue, and hyperspectral sensors were most often used to detect and identify disease symptoms, with current trends pointing to approaches integrating multiple sensors and the use of machine learning and deep learning techniques. The authors suggest that future research should prioritize (i) development of cost-effective and user-friendly UAVs, (ii) integration with emerging agricultural technologies, (iii) improved data acquisition and processing efficiency (iv) diverse testing scenarios, and (v) ethical considerations through proper regulations.\n\n![Source: @kouadio2023](imgs/RS-12.png){#fig-RS11 width=\"488\"}\n\n## Disease identification\n\nThis section illustrates the use of unmanned aerial vehicle (UAV) remote sensing imagery for identifying banana wilt disease. Fusarium wilt of banana, also known as \"banana cancer\", threatens banana production areas worldwide. Timely and accurate identification of Fusarium wilt disease is crucial for effective disease control and optimizing agricultural planting structure [@pegg2019].\n\nA common initial symptom of this disease is the appearance of a faint pale yellow streak at the base of the petiole of the oldest leaf. This is followed by leaf chlorosis which progresses from lower to upper leaves, wilting of leaves and longitudinal splitting of their bases. Pseudostem splitting of leaf bases is more common in young, rapidly growing plants [@pegg2019][@fig-RSfw].\n\n![Cavendish plant affected by Race 1 Foc (D. Peasley). Source: [@pegg2019]](https://www.frontiersin.org/files/Articles/469624/fpls-10-01395-HTML/image_m/fpls-10-01395-g006.jpg){#fig-RSfw fig-align=\"center\"}\n\n@ye2020 made publicly available experimental data [@HuichunYE2023] on wilted banana plants collected in a banana plantation located in Long'an County, Guangxi (China). The data set includes UAV multispectral reflectance data and ground survey data on the incidence of banana wilt disease. The paper by @ye2020 reports that the banana Fusarium wilt disease can be easily identified using several vegetation indices (VIs) obtained from this data set. Tested VIs include green chlorophyll index (CIgreen), red-edge chlorophyll index (CIRE), normalized difference vegetation index (NDVI), and normalized difference red-edge index (NDRE). The dataset can be downloaded from [here](https://www.scidb.cn/en/detail?dataSetId=8d77781a1d754db4b8842708a69c2c22).\n\n### Software setup\n\nLet's start by cleaning up R memory:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\n```\n:::\n\n\n\n\n\n\n\n\nThen, we need to install several packages (if they are not installed yet):\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.of.packages <- c(\"terra\", \n                      \"tidyterra\", \n                      \"stars\", \n                      \"sf\", \n                      \"leaflet\", \n                      \"leafem\", \n                      \"dplyr\", \n                      \"ggplot2\", \n                      \"tidymodels\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\n```\n:::\n\n\n\n\n\n\n\n\nNow, let's load all the required packages:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(stars)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leafem)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidymodels)\n```\n:::\n\n\n\n\n\n\n\n\n### Reading the dataset\n\nNext code supposes you have already downloaded the @HuichunYE2023 dataset and unzipped its content under the *data/banana_data* directory.\n\n### File formats\n\nLet's list the files under each subfolder:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"data/banana_data/1_UAV multispectral reflectance\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"UAV multispectral reflectance.tfw\"        \n[2] \"UAV multispectral reflectance.tif\"        \n[3] \"UAV multispectral reflectance.tif.aux.xml\"\n[4] \"UAV multispectral reflectance.tif.ovr\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that the *.tif* file contains an orthophotomosaic of surface reflectance. It was created from UAV images taken with a *Micasense Red Edge M* camera which has five narrow spectral bands: Blue (465--485 nm), green (550--570 nm), red (653--673 nm), red edge (712--722 nm), and near-infrared (800--880 nm). We assume here that those images have been radiometrically and geometrically corrected.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"data/banana_data/2_Ground survey data of banana Fusarium wilt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Ground_survey_data_of_banana_Fusarium_wilt.dbf\"    \n[2] \"Ground_survey_data_of_banana_Fusarium_wilt.prj\"    \n[3] \"Ground_survey_data_of_banana_Fusarium_wilt.sbn\"    \n[4] \"Ground_survey_data_of_banana_Fusarium_wilt.sbx\"    \n[5] \"Ground_survey_data_of_banana_Fusarium_wilt.shp\"    \n[6] \"Ground_survey_data_of_banana_Fusarium_wilt.shp.xml\"\n[7] \"Ground_survey_data_of_banana_Fusarium_wilt.shx\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThis is shapefile with 80 points where the plant health status was collected in same date as the images.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"data/banana_data/3_Boundary of banana planting region\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Boundary_of_banana_planting_region.dbf\"    \n[2] \"Boundary_of_banana_planting_region.prj\"    \n[3] \"Boundary_of_banana_planting_region.sbn\"    \n[4] \"Boundary_of_banana_planting_region.sbx\"    \n[5] \"Boundary_of_banana_planting_region.shp\"    \n[6] \"Boundary_of_banana_planting_region.shp.xml\"\n[7] \"Boundary_of_banana_planting_region.shx\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThis is a shapefile with one polygon representing the boundary of the study area.\n\n### Read the orthomosaic and the ground data\n\nNow, let's read the orthomosaic using the *terra* package:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Open the tif \ntif <- \"data/banana_data/1_UAV multispectral reflectance/UAV multispectral reflectance.tif\"\n\n\nrrr <- terra::rast(tif)\n```\n:::\n\n\n\n\n\n\n\n\nLet's check what we get:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrrr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 7885, 14420, 5  (nrow, ncol, nlyr)\nresolution  : 0.08, 0.08  (x, y)\nextent      : 779257.9, 780411.5, 2560496, 2561127  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 48N (EPSG:32648) \nsource      : UAV multispectral reflectance.tif \nnames       : UAV mu~ance_1, UAV mu~ance_2, UAV mu~ance_3, UAV mu~ance_4, UAV mu~ance_5 \nmin values  :      0.000000,      0.000000,      0.000000,     0.0000000,      0.000000 \nmax values  :      1.272638,      1.119109,      1.075701,     0.9651694,      1.069767 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that this is a 5-band multispectral image with 8 cm pixel size.\n\nNow, let's read the ground data:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshp <- \"data/banana_data/2_Ground survey data of banana Fusarium wilt/Ground_survey_data_of_banana_Fusarium_wilt.shp\"\nggg <- sf::st_read(shp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Ground_survey_data_of_banana_Fusarium_wilt' from data source \n  `/Users/emersondelponte/Documents/GitHub/epidemiology-R/data/banana_data/2_Ground survey data of banana Fusarium wilt/Ground_survey_data_of_banana_Fusarium_wilt.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 80 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 779548.9 ymin: 2560702 xmax: 780097 ymax: 2561020\nProjected CRS: WGS 84 / UTM zone 48N\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWhat we got?\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 779548.9 ymin: 2560702 xmax: 780097 ymax: 2561020\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n   OBJECTID 样点类型   x_经度   y_纬度                 geometry\n1         1 健康植株 107.7326 23.13240 POINT (779838.5 2560800)\n2         2 健康植株 107.7332 23.13316 POINT (779901.2 2560885)\n3         3 健康植株 107.7334 23.13394 POINT (779920.1 2560971)\n4         4 健康植株 107.7326 23.13430 POINT (779837.5 2561010)\n5         5 健康植株 107.7302 23.13225 POINT (779595.2 2560779)\n6         6 健康植株 107.7301 23.13190 POINT (779584.6 2560739)\n7         7 健康植株 107.7300 23.13297 POINT (779569.6 2560857)\n8         8 健康植株 107.7315 23.13301 POINT (779729.4 2560865)\n9         9 健康植株 107.7313 23.13245 POINT (779710.5 2560803)\n10       10 健康植株 107.7349 23.13307 POINT (780078.9 2560879)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that the attributes are in Chinese language. It seems that we will need to do several changes.\n\n### Visualizing the data\n\nAs the orthomosaic is too heavy to visualize, we will need a coarser version of it. Let's use the *terra* package for doing it.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrrr8 <- terra::aggregate(rrr, 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\n#terra <- resample(elev, template, method='bilinear')\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the output:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrrr8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 986, 1803, 5  (nrow, ncol, nlyr)\nresolution  : 0.64, 0.64  (x, y)\nextent      : 779257.9, 780411.8, 2560496, 2561127  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 48N (EPSG:32648) \nsource(s)   : memory\nnames       : UAV mu~ance_1, UAV mu~ance_2, UAV mu~ance_3, UAV mu~ance_4, UAV mu~ance_5 \nmin values  :      0.000000,      0.000000,      0.000000,      0.000000,      0.000000 \nmax values  :      1.272638,      1.119109,      1.075701,      0.949925,      1.069767 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that the pixel size of the aggregated raster is 64 cm. Now, in order to visualize the ground points, we will need a color palette:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npal <- colorFactor(\n  palette = c('green',  'red'),\n  domain = ggg$样点类型\n)\n```\n:::\n\n\n\n\n\n\n\n\nThen, we will use the *leaflet* package to plot the new image and the ground points:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = ggg) |>\n  addProviderTiles(\"Esri.WorldImagery\") |>\n  addRasterImage(rrr8) |>\n  addCircleMarkers(~x_经度, ~y_纬度,\n    radius = 5,\n    label = ~样点类型,\n    fillColor = ~pal(样点类型),  \n    fillOpacity = 1,\n    stroke = F)\n```\n\n::: {.cell-output-display}\n![](data-remote-sensing_files/figure-docx/unnamed-chunk-14-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n### Extracting image values at sampled points\n\nNow we will extract raster values at point locations using the `st_extract()` function from the {stars} library. It is expected that a value per band is extracted at each point.\n\nWe need to convert the *raster* object into a *stars* object:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsss <- st_as_stars(rrr)\n```\n:::\n\n\n\n\n\n\n\n\nWhat we got?\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsss\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstars_proxy object with 1 attribute in 1 file(s):\n$`UAV multispectral reflectance.tif`\n[1] \"[...]/UAV multispectral reflectance.tif\"\n\ndimension(s):\n     from    to  offset delta                refsys point x/y\nx       1 14420  779258  0.08 WGS 84 / UTM zone 48N FALSE [x]\ny       1  7885 2561127 -0.08 WGS 84 / UTM zone 48N FALSE [y]\nband    1     5      NA    NA                    NA    NA    \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nBefore conducting the extraction task, it is advisable to collect band values not at a single pixel but at a small window (e.g. 3x3 pixels). Thus, we will start creating 20cm buffers at each site:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoly <- st_buffer(ggg, dist = 0.20)\n```\n:::\n\n\n\n\n\n\n\n\nNow, the extraction task:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the median value per polygon\nbuf_values <- aggregate(sss, poly, FUN = median) |>\n  st_as_sf()\n```\n:::\n\n\n\n\n\n\n\n\nWhat we got:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf_values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 779548.7 ymin: 2560702 xmax: 780097.2 ymax: 2561021\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n   UAV multispectral reflectance.tif.V1 UAV multispectral reflectance.tif.V2\n1                             0.2837147                            0.3570867\n2                             0.3096394                            0.4598360\n3                             0.2652082                            0.3556182\n4                             0.2729177                            0.3626878\n5                             0.3033864                            0.3089822\n6                             0.2993084                            0.3655908\n7                             0.2471483                            0.2859972\n8                             0.2491679                            0.3223873\n9                             0.3213297                            0.4069843\n10                            0.2976966                            0.3430840\n   UAV multispectral reflectance.tif.V3 UAV multispectral reflectance.tif.V4\n1                             0.2049306                            0.6370987\n2                             0.2058005                            0.6609572\n3                             0.1769855                            0.5988070\n4                             0.1828043                            0.7094992\n5                             0.1894684                            0.6805743\n6                             0.1988409                            0.7750074\n7                             0.1880568                            0.5221797\n8                             0.1855947                            0.5934904\n9                             0.2013687                            0.5593004\n10                            0.2144508                            0.8057290\n   UAV multispectral reflectance.tif.V5                       geometry\n1                             0.4779058 POLYGON ((779838.7 2560800,...\n2                             0.5714727 POLYGON ((779901.4 2560885,...\n3                             0.4352523 POLYGON ((779920.3 2560971,...\n4                             0.5149931 POLYGON ((779837.7 2561010,...\n5                             0.4008912 POLYGON ((779595.4 2560779,...\n6                             0.4967270 POLYGON ((779584.8 2560739,...\n7                             0.3308629 POLYGON ((779569.8 2560857,...\n8                             0.4570443 POLYGON ((779729.6 2560865,...\n9                             0.5094757 POLYGON ((779710.7 2560803,...\n10                            0.5005793 POLYGON ((780079.1 2560879,...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that names of bands are weird:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(buf_values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"UAV multispectral reflectance.tif.V1\"\n[2] \"UAV multispectral reflectance.tif.V2\"\n[3] \"UAV multispectral reflectance.tif.V3\"\n[4] \"UAV multispectral reflectance.tif.V4\"\n[5] \"UAV multispectral reflectance.tif.V5\"\n[6] \"geometry\"                            \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLet's rename band values:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf_values |> rename(blue = \"UAV multispectral reflectance.tif.V1\",\n                      red = \"UAV multispectral reflectance.tif.V2\",\n                      green = \"UAV multispectral reflectance.tif.V3\",\n                      redge = \"UAV multispectral reflectance.tif.V4\",\n                      nir = \"UAV multispectral reflectance.tif.V5\") -> buf_values2\n```\n:::\n\n\n\n\n\n\n\n\nNow, we got shorter names per band:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf_values2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 779548.7 ymin: 2560702 xmax: 780097.2 ymax: 2561021\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n        blue       red     green     redge       nir\n1  0.2837147 0.3570867 0.2049306 0.6370987 0.4779058\n2  0.3096394 0.4598360 0.2058005 0.6609572 0.5714727\n3  0.2652082 0.3556182 0.1769855 0.5988070 0.4352523\n4  0.2729177 0.3626878 0.1828043 0.7094992 0.5149931\n5  0.3033864 0.3089822 0.1894684 0.6805743 0.4008912\n6  0.2993084 0.3655908 0.1988409 0.7750074 0.4967270\n7  0.2471483 0.2859972 0.1880568 0.5221797 0.3308629\n8  0.2491679 0.3223873 0.1855947 0.5934904 0.4570443\n9  0.3213297 0.4069843 0.2013687 0.5593004 0.5094757\n10 0.2976966 0.3430840 0.2144508 0.8057290 0.5005793\n                         geometry\n1  POLYGON ((779838.7 2560800,...\n2  POLYGON ((779901.4 2560885,...\n3  POLYGON ((779920.3 2560971,...\n4  POLYGON ((779837.7 2561010,...\n5  POLYGON ((779595.4 2560779,...\n6  POLYGON ((779584.8 2560739,...\n7  POLYGON ((779569.8 2560857,...\n8  POLYGON ((779729.6 2560865,...\n9  POLYGON ((779710.7 2560803,...\n10 POLYGON ((780079.1 2560879,...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Computing vegetation indices\n\n@ye2020 used the following indices [@fig-RS12]:\n\n![](imgs/RS_VIs.png){#fig-RS12 fig-align=\"center\"}\n\nThus, we will compute several of those indices:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf_indices <-  buf_values2 |> \n  mutate(ndvi = (nir - red) / (nir+red),\n         ndre = (nir - redge) / (nir+redge),\n          cire = (nir) / (redge-1),\n          sipi = (nir - blue) / (redge-red)\n  ) |> select(ndvi, ndre, cire, sipi)\n```\n:::\n\n\n\n\n\n\n\n\nWhat we got:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf_indices\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 779548.7 ymin: 2560702 xmax: 780097.2 ymax: 2561021\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n         ndvi        ndre       cire      sipi                       geometry\n1  0.14469485 -0.14277326 -1.3169030 0.6935100 POLYGON ((779838.7 2560800,...\n2  0.10824757 -0.07260820 -1.6855475 1.3018684 POLYGON ((779901.4 2560885,...\n3  0.10069173 -0.15816766 -1.0848951 0.6992264 POLYGON ((779920.3 2560971,...\n4  0.17353146 -0.15884638 -1.7727770 0.6980030 POLYGON ((779837.7 2561010,...\n5  0.12947229 -0.25861496 -1.2550373 0.2623973 POLYGON ((779595.4 2560779,...\n6  0.15207400 -0.21881961 -2.2077477 0.4821950 POLYGON ((779584.8 2560739,...\n7  0.07273232 -0.22427574 -0.6924421 0.3544487 POLYGON ((779569.8 2560857,...\n8  0.17276311 -0.12988254 -1.1243137 0.7667796 POLYGON ((779729.6 2560865,...\n9  0.11183404 -0.04661848 -1.1560613 1.2352333 POLYGON ((779710.7 2560803,...\n10 0.18668031 -0.23359699 -2.5767059 0.4385279 POLYGON ((780079.1 2560879,...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that the health status is missing in *buf_indices*. Therefore, we will need to use a spatial join to link such status:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- st_join(\n  ggg,\n  buf_indices,\n  join = st_intersects)\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the output:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 8 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 779548.9 ymin: 2560702 xmax: 780097 ymax: 2561020\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n   OBJECTID 样点类型   x_经度   y_纬度       ndvi        ndre       cire\n1         1 健康植株 107.7326 23.13240 0.14469485 -0.14277326 -1.3169030\n2         2 健康植株 107.7332 23.13316 0.10824757 -0.07260820 -1.6855475\n3         3 健康植株 107.7334 23.13394 0.10069173 -0.15816766 -1.0848951\n4         4 健康植株 107.7326 23.13430 0.17353146 -0.15884638 -1.7727770\n5         5 健康植株 107.7302 23.13225 0.12947229 -0.25861496 -1.2550373\n6         6 健康植株 107.7301 23.13190 0.15207400 -0.21881961 -2.2077477\n7         7 健康植株 107.7300 23.13297 0.07273232 -0.22427574 -0.6924421\n8         8 健康植株 107.7315 23.13301 0.17276311 -0.12988254 -1.1243137\n9         9 健康植株 107.7313 23.13245 0.11183404 -0.04661848 -1.1560613\n10       10 健康植株 107.7349 23.13307 0.18668031 -0.23359699 -2.5767059\n        sipi                 geometry\n1  0.6935100 POINT (779838.5 2560800)\n2  1.3018684 POINT (779901.2 2560885)\n3  0.6992264 POINT (779920.1 2560971)\n4  0.6980030 POINT (779837.5 2561010)\n5  0.2623973 POINT (779595.2 2560779)\n6  0.4821950 POINT (779584.6 2560739)\n7  0.3544487 POINT (779569.6 2560857)\n8  0.7667796 POINT (779729.4 2560865)\n9  1.2352333 POINT (779710.5 2560803)\n10 0.4385279 POINT (780078.9 2560879)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIt seems we succeeded.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(samples$样点类型)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"健康植株\"   \"枯萎病植株\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLet's check it:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 8 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 779548.9 ymin: 2560702 xmax: 780097 ymax: 2561020\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n   OBJECTID 样点类型   x_经度   y_纬度       ndvi        ndre       cire\n1         1 健康植株 107.7326 23.13240 0.14469485 -0.14277326 -1.3169030\n2         2 健康植株 107.7332 23.13316 0.10824757 -0.07260820 -1.6855475\n3         3 健康植株 107.7334 23.13394 0.10069173 -0.15816766 -1.0848951\n4         4 健康植株 107.7326 23.13430 0.17353146 -0.15884638 -1.7727770\n5         5 健康植株 107.7302 23.13225 0.12947229 -0.25861496 -1.2550373\n6         6 健康植株 107.7301 23.13190 0.15207400 -0.21881961 -2.2077477\n7         7 健康植株 107.7300 23.13297 0.07273232 -0.22427574 -0.6924421\n8         8 健康植株 107.7315 23.13301 0.17276311 -0.12988254 -1.1243137\n9         9 健康植株 107.7313 23.13245 0.11183404 -0.04661848 -1.1560613\n10       10 健康植株 107.7349 23.13307 0.18668031 -0.23359699 -2.5767059\n        sipi                 geometry\n1  0.6935100 POINT (779838.5 2560800)\n2  1.3018684 POINT (779901.2 2560885)\n3  0.6992264 POINT (779920.1 2560971)\n4  0.6980030 POINT (779837.5 2561010)\n5  0.2623973 POINT (779595.2 2560779)\n6  0.4821950 POINT (779584.6 2560739)\n7  0.3544487 POINT (779569.6 2560857)\n8  0.7667796 POINT (779729.4 2560865)\n9  1.2352333 POINT (779710.5 2560803)\n10 0.4385279 POINT (780078.9 2560879)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNow, we will replace the Chinese words for English words:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples |> \n  mutate(score = ifelse(样点类型 == '健康植株', 'healthy', 'wilted')) |>\n  rename(east = x_经度,\n         north = y_纬度 ) |>\n  select(OBJECTID,score, ndvi, ndre, cire, sipi) -> nsamples\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the output:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 80 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 779548.9 ymin: 2560702 xmax: 780097 ymax: 2561020\nProjected CRS: WGS 84 / UTM zone 48N\nFirst 10 features:\n   OBJECTID   score       ndvi        ndre       cire      sipi\n1         1 healthy 0.14469485 -0.14277326 -1.3169030 0.6935100\n2         2 healthy 0.10824757 -0.07260820 -1.6855475 1.3018684\n3         3 healthy 0.10069173 -0.15816766 -1.0848951 0.6992264\n4         4 healthy 0.17353146 -0.15884638 -1.7727770 0.6980030\n5         5 healthy 0.12947229 -0.25861496 -1.2550373 0.2623973\n6         6 healthy 0.15207400 -0.21881961 -2.2077477 0.4821950\n7         7 healthy 0.07273232 -0.22427574 -0.6924421 0.3544487\n8         8 healthy 0.17276311 -0.12988254 -1.1243137 0.7667796\n9         9 healthy 0.11183404 -0.04661848 -1.1560613 1.2352333\n10       10 healthy 0.18668031 -0.23359699 -2.5767059 0.4385279\n                   geometry\n1  POINT (779838.5 2560800)\n2  POINT (779901.2 2560885)\n3  POINT (779920.1 2560971)\n4  POINT (779837.5 2561010)\n5  POINT (779595.2 2560779)\n6  POINT (779584.6 2560739)\n7  POINT (779569.6 2560857)\n8  POINT (779729.4 2560865)\n9  POINT (779710.5 2560803)\n10 POINT (780078.9 2560879)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAs we will not intend to use the geometry in our model, we can remove it:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(nsamples) <- NULL\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the output:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   OBJECTID   score       ndvi         ndre       cire        sipi\n1         1 healthy 0.14469485 -0.142773261 -1.3169030   0.6935100\n2         2 healthy 0.10824757 -0.072608196 -1.6855475   1.3018684\n3         3 healthy 0.10069173 -0.158167658 -1.0848951   0.6992264\n4         4 healthy 0.17353146 -0.158846378 -1.7727770   0.6980030\n5         5 healthy 0.12947229 -0.258614958 -1.2550373   0.2623973\n6         6 healthy 0.15207400 -0.218819608 -2.2077477   0.4821950\n7         7 healthy 0.07273232 -0.224275739 -0.6924421   0.3544487\n8         8 healthy 0.17276311 -0.129882540 -1.1243137   0.7667796\n9         9 healthy 0.11183404 -0.046618476 -1.1560613   1.2352333\n10       10 healthy 0.18668031 -0.233596986 -2.5767059   0.4385279\n11       11 healthy 0.18657437 -0.228953927 -1.1653227   0.4062720\n12       12 healthy 0.08643499 -0.140911613 -0.8354715   0.6312134\n13       13 healthy 0.15674017 -0.196911688 -3.7608107   0.5867844\n14       14  wilted 0.11821422 -0.068648057 -0.8355714   1.0732255\n15       15  wilted 0.09439201  0.038426164 -1.6886927   3.9928701\n16       16  wilted 0.11179310  0.099664192 -1.2926303  19.6185081\n17       17  wilted 0.09110226 -0.012808011 -0.6207856   1.8658238\n18       18  wilted 0.05483186  0.059516988 -1.0249783 -53.7256928\n19       19  wilted 0.10296918  0.050902211 -0.5312504  -2.0705492\n20       20  wilted 0.09142250  0.166594498 -1.3738936  -4.5687561\n21       21  wilted 0.08282444  0.150849653 -1.0515823  -2.7751200\n22       22  wilted 0.09622230 -0.026842737 -1.8046361   1.7472896\n23       23  wilted 0.10804655  0.128742778 -3.1489130 -15.9373140\n24       24  wilted 0.11759462 -0.271995471 -0.7296435   0.3251888\n25       25  wilted 0.14612901 -0.170267124 -0.7535340   0.4340166\n26       26  wilted 0.14345746  0.007804645 -1.0917760   1.7195275\n27       27  wilted 0.09668988  0.048839732 -0.8969843   3.4761651\n28       28  wilted 0.16690104  0.009134113 -1.8204254   1.9231470\n29       29  wilted 0.12475996  0.018023671 -1.1985424   2.1736919\n30       30  wilted 0.12287255 -0.144575443 -0.7030899   0.5607103\n31       31  wilted 0.13276824  0.058621948 -1.4800599   3.5889606\n32       32  wilted 0.05301838 -0.056220022 -1.6759833   1.7895973\n33       33  wilted 0.14595352 -0.119623392 -1.4439231   0.8741458\n34       34  wilted 0.11236478 -0.015965114 -1.0488215   1.6813047\n35       35  wilted 0.20042051  0.007888690 -1.9802223   1.6851630\n36       36  wilted 0.14792880 -0.186300667 -0.7084196   0.3644668\n37       37  wilted 0.11381952  0.049444260 -1.1052035   3.7268769\n38       38  wilted 0.12729611  0.049169099 -0.6510980   1.2817601\n39       39  wilted 0.16311398 -0.075256088 -1.1007427   0.4779209\n40       40  wilted 0.12317018 -0.043296886 -0.7492018   0.9707563\n41       41  wilted 0.11177875  0.012897741 -1.8978005   2.8596823\n42       42  wilted 0.09087224  0.100019670 -1.0620017 -29.9002728\n43       43  wilted 0.15791341 -0.005372302 -1.5073174   1.7255063\n44       44  wilted 0.13393783 -0.023050553 -0.8915742   1.0855461\n45       45  wilted 0.06276064 -0.058164786 -1.0170161   1.4100601\n46       46  wilted 0.14991261 -0.080920969 -1.5173127   1.1947273\n47       47  wilted 0.15454129 -0.029567154 -1.4345890   1.8891207\n48       48  wilted 0.17448058  0.053204886 -0.9757240   2.8155912\n49       49 healthy 0.10767838 -0.279952871 -1.2310963   0.2743482\n50       50  wilted 0.11253491 -0.001355745 -1.0156727   2.0230335\n51       51 healthy 0.17156708 -0.130486894 -0.9670619   0.5846040\n52       52 healthy 0.11201780 -0.240080432 -1.5616428   0.3767992\n53       53 healthy 0.11357791 -0.233516246 -0.7266852   0.5174349\n54       54 healthy 0.09640389 -0.197173474 -1.6740870   0.6429254\n55       55 healthy 0.10371600 -0.148771702 -1.7079973   0.6404103\n56       56 healthy 0.13733091 -0.192621610 -1.0920985   0.5104957\n57       57 healthy 0.10494961 -0.141993366 -0.9767054   0.7876503\n58       58 healthy 0.09594242 -0.238072742 -1.2599388   0.4055777\n59       59 healthy 0.12253980 -0.228534207 -0.6240105   0.3125564\n60       60 healthy 0.11191907 -0.200302031 -1.6484365   0.4100274\n61       61 healthy 0.17497565 -0.348438178 -0.8327460   0.2617154\n62       62 healthy 0.06286945 -0.066868925 -1.9457173   0.9082508\n63       63 healthy 0.15875140 -0.180227754 -1.1609626   0.5244801\n64       64 healthy 0.12946220 -0.116778741 -1.1471938   0.6492517\n65       65 healthy 0.13029153 -0.251235648 -1.1507658   0.3096142\n66       66 healthy 0.18309513 -0.237002851 -2.1102911   0.4401729\n67       67 healthy 0.18231241 -0.191220292 -1.5998799   0.5043085\n68       68 healthy 0.12550657 -0.238273304 -0.8386376   0.3827526\n69       69 healthy 0.15353233 -0.215340798 -2.9878736   0.5652307\n70       70 healthy 0.17299827 -0.279709014 -1.4354651   0.3986933\n71       71 healthy 0.10020553 -0.181384162 -1.4309319   0.4048364\n72       72 healthy 0.16533571 -0.222465226 -1.4819059   0.4107726\n73       73 healthy 0.16081598  0.009196845 -1.1312141   2.2696678\n74       74 healthy 0.10260883 -0.288149676 -0.8375206   0.2317196\n75       75 healthy 0.19372839 -0.149982883 -2.4120161   0.7065984\n76       76 healthy 0.17650050 -0.249396644 -1.5425889   0.4227645\n77       77  wilted 0.13466946 -0.014630713 -1.1275266   1.7332531\n78       78  wilted 0.14542428  0.035346511 -1.3640391   2.9550260\n79       79  wilted 0.16581448  0.097763989 -1.0057000   4.8381045\n80       80  wilted 0.07985435  0.045756804 -1.3962020   7.5734216\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAs our task is a binary classification (i.e any site can be either healthy or wilted), the variable to estimate is a *factor* (not a character).\n\nLet's change the data type of such variable:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsamples$score = as.factor(nsamples$score) \n```\n:::\n\n\n\n\n\n\n\n\nLet's check the result:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   OBJECTID   score       ndvi         ndre       cire        sipi\n1         1 healthy 0.14469485 -0.142773261 -1.3169030   0.6935100\n2         2 healthy 0.10824757 -0.072608196 -1.6855475   1.3018684\n3         3 healthy 0.10069173 -0.158167658 -1.0848951   0.6992264\n4         4 healthy 0.17353146 -0.158846378 -1.7727770   0.6980030\n5         5 healthy 0.12947229 -0.258614958 -1.2550373   0.2623973\n6         6 healthy 0.15207400 -0.218819608 -2.2077477   0.4821950\n7         7 healthy 0.07273232 -0.224275739 -0.6924421   0.3544487\n8         8 healthy 0.17276311 -0.129882540 -1.1243137   0.7667796\n9         9 healthy 0.11183404 -0.046618476 -1.1560613   1.2352333\n10       10 healthy 0.18668031 -0.233596986 -2.5767059   0.4385279\n11       11 healthy 0.18657437 -0.228953927 -1.1653227   0.4062720\n12       12 healthy 0.08643499 -0.140911613 -0.8354715   0.6312134\n13       13 healthy 0.15674017 -0.196911688 -3.7608107   0.5867844\n14       14  wilted 0.11821422 -0.068648057 -0.8355714   1.0732255\n15       15  wilted 0.09439201  0.038426164 -1.6886927   3.9928701\n16       16  wilted 0.11179310  0.099664192 -1.2926303  19.6185081\n17       17  wilted 0.09110226 -0.012808011 -0.6207856   1.8658238\n18       18  wilted 0.05483186  0.059516988 -1.0249783 -53.7256928\n19       19  wilted 0.10296918  0.050902211 -0.5312504  -2.0705492\n20       20  wilted 0.09142250  0.166594498 -1.3738936  -4.5687561\n21       21  wilted 0.08282444  0.150849653 -1.0515823  -2.7751200\n22       22  wilted 0.09622230 -0.026842737 -1.8046361   1.7472896\n23       23  wilted 0.10804655  0.128742778 -3.1489130 -15.9373140\n24       24  wilted 0.11759462 -0.271995471 -0.7296435   0.3251888\n25       25  wilted 0.14612901 -0.170267124 -0.7535340   0.4340166\n26       26  wilted 0.14345746  0.007804645 -1.0917760   1.7195275\n27       27  wilted 0.09668988  0.048839732 -0.8969843   3.4761651\n28       28  wilted 0.16690104  0.009134113 -1.8204254   1.9231470\n29       29  wilted 0.12475996  0.018023671 -1.1985424   2.1736919\n30       30  wilted 0.12287255 -0.144575443 -0.7030899   0.5607103\n31       31  wilted 0.13276824  0.058621948 -1.4800599   3.5889606\n32       32  wilted 0.05301838 -0.056220022 -1.6759833   1.7895973\n33       33  wilted 0.14595352 -0.119623392 -1.4439231   0.8741458\n34       34  wilted 0.11236478 -0.015965114 -1.0488215   1.6813047\n35       35  wilted 0.20042051  0.007888690 -1.9802223   1.6851630\n36       36  wilted 0.14792880 -0.186300667 -0.7084196   0.3644668\n37       37  wilted 0.11381952  0.049444260 -1.1052035   3.7268769\n38       38  wilted 0.12729611  0.049169099 -0.6510980   1.2817601\n39       39  wilted 0.16311398 -0.075256088 -1.1007427   0.4779209\n40       40  wilted 0.12317018 -0.043296886 -0.7492018   0.9707563\n41       41  wilted 0.11177875  0.012897741 -1.8978005   2.8596823\n42       42  wilted 0.09087224  0.100019670 -1.0620017 -29.9002728\n43       43  wilted 0.15791341 -0.005372302 -1.5073174   1.7255063\n44       44  wilted 0.13393783 -0.023050553 -0.8915742   1.0855461\n45       45  wilted 0.06276064 -0.058164786 -1.0170161   1.4100601\n46       46  wilted 0.14991261 -0.080920969 -1.5173127   1.1947273\n47       47  wilted 0.15454129 -0.029567154 -1.4345890   1.8891207\n48       48  wilted 0.17448058  0.053204886 -0.9757240   2.8155912\n49       49 healthy 0.10767838 -0.279952871 -1.2310963   0.2743482\n50       50  wilted 0.11253491 -0.001355745 -1.0156727   2.0230335\n51       51 healthy 0.17156708 -0.130486894 -0.9670619   0.5846040\n52       52 healthy 0.11201780 -0.240080432 -1.5616428   0.3767992\n53       53 healthy 0.11357791 -0.233516246 -0.7266852   0.5174349\n54       54 healthy 0.09640389 -0.197173474 -1.6740870   0.6429254\n55       55 healthy 0.10371600 -0.148771702 -1.7079973   0.6404103\n56       56 healthy 0.13733091 -0.192621610 -1.0920985   0.5104957\n57       57 healthy 0.10494961 -0.141993366 -0.9767054   0.7876503\n58       58 healthy 0.09594242 -0.238072742 -1.2599388   0.4055777\n59       59 healthy 0.12253980 -0.228534207 -0.6240105   0.3125564\n60       60 healthy 0.11191907 -0.200302031 -1.6484365   0.4100274\n61       61 healthy 0.17497565 -0.348438178 -0.8327460   0.2617154\n62       62 healthy 0.06286945 -0.066868925 -1.9457173   0.9082508\n63       63 healthy 0.15875140 -0.180227754 -1.1609626   0.5244801\n64       64 healthy 0.12946220 -0.116778741 -1.1471938   0.6492517\n65       65 healthy 0.13029153 -0.251235648 -1.1507658   0.3096142\n66       66 healthy 0.18309513 -0.237002851 -2.1102911   0.4401729\n67       67 healthy 0.18231241 -0.191220292 -1.5998799   0.5043085\n68       68 healthy 0.12550657 -0.238273304 -0.8386376   0.3827526\n69       69 healthy 0.15353233 -0.215340798 -2.9878736   0.5652307\n70       70 healthy 0.17299827 -0.279709014 -1.4354651   0.3986933\n71       71 healthy 0.10020553 -0.181384162 -1.4309319   0.4048364\n72       72 healthy 0.16533571 -0.222465226 -1.4819059   0.4107726\n73       73 healthy 0.16081598  0.009196845 -1.1312141   2.2696678\n74       74 healthy 0.10260883 -0.288149676 -0.8375206   0.2317196\n75       75 healthy 0.19372839 -0.149982883 -2.4120161   0.7065984\n76       76 healthy 0.17650050 -0.249396644 -1.5425889   0.4227645\n77       77  wilted 0.13466946 -0.014630713 -1.1275266   1.7332531\n78       78  wilted 0.14542428  0.035346511 -1.3640391   2.9550260\n79       79  wilted 0.16581448  0.097763989 -1.0057000   4.8381045\n80       80  wilted 0.07985435  0.045756804 -1.3962020   7.5734216\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nA simple summary of the extracted data can be useful:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsamples |>\n  group_by(score) |>\n  summarize(n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  score   `n()`\n  <fct>   <int>\n1 healthy    40\n2 wilted     40\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThis mean the dataset is balanced which is very good.\n\n### Saving the extracted dataset\n\nNow, let's save the *nsamples* object. Just in case R crashes due to lack of memory.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#uncomment if needed\n#st_write(nsamples, \"./banana_data/nsamples.csv\", overwrite=TRUE)\n```\n:::\n\n\n\n\n\n\n\n\n### Classification of Fusarium wilt using machine learning (ML)\n\nThe overall process to classify the crop disease under study will be conducted using the [*tidymodels* framework](https://www.tidymodels.org/) which is an extension of the *tidyverse* suite. It is especially focused towards providing a generalized way to define, run and optimize ML models in R.\n\n#### Exploratory analysis\n\nAs a first step in modeling, it's always a good idea to visualize the data. Let's start with a *boxplot* to displays the distribution of a vegetation index. It visualizes five summary statistics (the median, two hinges and two whiskers), and all \"outlying\" points individually.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(nsamples, aes(score, ndre))+\n  r4pde::theme_r4pde()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: replacing previous import 'car::recode' by 'dplyr::recode' when\nloading 'r4pde'\n```\n\n\n:::\n\n```{.r .cell-code}\np + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](data-remote-sensing_files/figure-docx/unnamed-chunk-37-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\nNext, we will do a scatterplot to visualize the indices NDRE and CIRE:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nsamples) +\n  aes(x = ndre, y = cire, color = score) +\n  geom_point(shape = 16, size = 4) +\n  labs(x = \"NDRE\", y = \"CIRI\") +\n  r4pde::theme_r4pde() +\n  scale_color_manual(values = c(\"#71b075\", \"#ba0600\"))\n```\n\n::: {.cell-output-display}\n![](data-remote-sensing_files/figure-docx/unnamed-chunk-38-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n#### Splitting the data\n\nNext step is to divide the data into a training and a test set. The `set.seed()` function can be used for reproducibility of the computations that are dependent on random numbers. By default, the training/testing split is 0.75 to 0.25.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\ndata_split <- initial_split(data = nsamples)\ndata_train <- training(data_split)\ndata_test <- testing(data_split)\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the result:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_train\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   OBJECTID   score       ndvi         ndre       cire        sipi\n1        49 healthy 0.10767838 -0.279952871 -1.2310963   0.2743482\n2        65 healthy 0.13029153 -0.251235648 -1.1507658   0.3096142\n3        25  wilted 0.14612901 -0.170267124 -0.7535340   0.4340166\n4        74 healthy 0.10260883 -0.288149676 -0.8375206   0.2317196\n5        18  wilted 0.05483186  0.059516988 -1.0249783 -53.7256928\n6        80  wilted 0.07985435  0.045756804 -1.3962020   7.5734216\n7        47  wilted 0.15454129 -0.029567154 -1.4345890   1.8891207\n8        24  wilted 0.11759462 -0.271995471 -0.7296435   0.3251888\n9        71 healthy 0.10020553 -0.181384162 -1.4309319   0.4048364\n10       37  wilted 0.11381952  0.049444260 -1.1052035   3.7268769\n11       20  wilted 0.09142250  0.166594498 -1.3738936  -4.5687561\n12       26  wilted 0.14345746  0.007804645 -1.0917760   1.7195275\n13        3 healthy 0.10069173 -0.158167658 -1.0848951   0.6992264\n14       41  wilted 0.11177875  0.012897741 -1.8978005   2.8596823\n15       27  wilted 0.09668988  0.048839732 -0.8969843   3.4761651\n16       36  wilted 0.14792880 -0.186300667 -0.7084196   0.3644668\n17       72 healthy 0.16533571 -0.222465226 -1.4819059   0.4107726\n18       31  wilted 0.13276824  0.058621948 -1.4800599   3.5889606\n19       45  wilted 0.06276064 -0.058164786 -1.0170161   1.4100601\n20        5 healthy 0.12947229 -0.258614958 -1.2550373   0.2623973\n21       70 healthy 0.17299827 -0.279709014 -1.4354651   0.3986933\n22       34  wilted 0.11236478 -0.015965114 -1.0488215   1.6813047\n23       28  wilted 0.16690104  0.009134113 -1.8204254   1.9231470\n24       40  wilted 0.12317018 -0.043296886 -0.7492018   0.9707563\n25       68 healthy 0.12550657 -0.238273304 -0.8386376   0.3827526\n26       33  wilted 0.14595352 -0.119623392 -1.4439231   0.8741458\n27       42  wilted 0.09087224  0.100019670 -1.0620017 -29.9002728\n28       73 healthy 0.16081598  0.009196845 -1.1312141   2.2696678\n29       30  wilted 0.12287255 -0.144575443 -0.7030899   0.5607103\n30       43  wilted 0.15791341 -0.005372302 -1.5073174   1.7255063\n31       15  wilted 0.09439201  0.038426164 -1.6886927   3.9928701\n32       22  wilted 0.09622230 -0.026842737 -1.8046361   1.7472896\n33        8 healthy 0.17276311 -0.129882540 -1.1243137   0.7667796\n34       79  wilted 0.16581448  0.097763989 -1.0057000   4.8381045\n35        4 healthy 0.17353146 -0.158846378 -1.7727770   0.6980030\n36       75 healthy 0.19372839 -0.149982883 -2.4120161   0.7065984\n37       76 healthy 0.17650050 -0.249396644 -1.5425889   0.4227645\n38       58 healthy 0.09594242 -0.238072742 -1.2599388   0.4055777\n39       61 healthy 0.17497565 -0.348438178 -0.8327460   0.2617154\n40       46  wilted 0.14991261 -0.080920969 -1.5173127   1.1947273\n41       59 healthy 0.12253980 -0.228534207 -0.6240105   0.3125564\n42       35  wilted 0.20042051  0.007888690 -1.9802223   1.6851630\n43       53 healthy 0.11357791 -0.233516246 -0.7266852   0.5174349\n44       23  wilted 0.10804655  0.128742778 -3.1489130 -15.9373140\n45       69 healthy 0.15353233 -0.215340798 -2.9878736   0.5652307\n46        6 healthy 0.15207400 -0.218819608 -2.2077477   0.4821950\n47       39  wilted 0.16311398 -0.075256088 -1.1007427   0.4779209\n48        2 healthy 0.10824757 -0.072608196 -1.6855475   1.3018684\n49       60 healthy 0.11191907 -0.200302031 -1.6484365   0.4100274\n50       56 healthy 0.13733091 -0.192621610 -1.0920985   0.5104957\n51       62 healthy 0.06286945 -0.066868925 -1.9457173   0.9082508\n52       21  wilted 0.08282444  0.150849653 -1.0515823  -2.7751200\n53       55 healthy 0.10371600 -0.148771702 -1.7079973   0.6404103\n54       64 healthy 0.12946220 -0.116778741 -1.1471938   0.6492517\n55       57 healthy 0.10494961 -0.141993366 -0.9767054   0.7876503\n56       10 healthy 0.18668031 -0.233596986 -2.5767059   0.4385279\n57       48  wilted 0.17448058  0.053204886 -0.9757240   2.8155912\n58       54 healthy 0.09640389 -0.197173474 -1.6740870   0.6429254\n59        1 healthy 0.14469485 -0.142773261 -1.3169030   0.6935100\n60       17  wilted 0.09110226 -0.012808011 -0.6207856   1.8658238\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n#### Defining the model\n\nWe will use a logistic regression which is a simple model. It may be useful to have a look at [this explanation](https://mlu-explain.github.io/logistic-regression/) of such a model.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspec_lr <-\nlogistic_reg() |> \n  set_engine(\"glm\") |> \n  set_mode(\"classification\")\n```\n:::\n\n\n\n\n\n\n\n\n#### Defining the recipe\n\nThe `recipe()` function to be used here has two arguments:\n\n-   A formula. Any variable on the left-hand side of the tilde (\\~) is considered the model outcome (here, outcome). On the right-hand side of the tilde are the predictors. Variables may be listed by name, or you can use the dot (.) to indicate all other variables as predictors.\n\n-   The data. A recipe is associated with the data set used to create the model. This will typically be the training set, so `data = data_train` here.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecipe_lr <-\n  recipe(score ~ ., data_train) |>\n  add_role(OBJECTID, new_role = \"id\") |>\n  step_zv(all_predictors()) |>\n  step_corr(all_predictors())\n```\n:::\n\n\n\n\n\n\n\n\n#### Evaluating model performance\n\nNext, we need to specify what we would like to see for determining the performance of the model. Different modelling algorithms have different types of metrics. Because we have a binary classification problem (healthy vs. wilted classification), we will chose the AUC - ROC evaluation metric here.\n\n#### Combining model and recipe into a workflow\n\nWe will want to use our recipe across several steps as we train and test our model. We will:\n\n-   Process the recipe using the training set: This involves any estimation or calculations based on the training set. For our recipe, the training set will be used to determine which predictors should be converted to dummy variables and which predictors will have zero-variance in the training set, and should be slated for removal.\n\n-   Apply the recipe to the training set: We create the final predictor set on the training set.\n\n-   Apply the recipe to the test set: We create the final predictor set on the test set. Nothing is recomputed and no information from the test set is used here; the dummy variable and zero-variance results from the training set are applied to the test set.\n\nTo simplify this process, we can use a model workflow, which pairs a model and recipe together. This is a straightforward approach because different recipes are often needed for different models, so when a model and recipe are bundled, it becomes easier to train and test workflows. We'll use the workflows package from *tidymodels* to bundle our model with our recipe.\n\nNow we are ready to setup our complete modelling workflow. This workflow contains the model specification and the recipe.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwf_bana_wilt <-\n  workflow(\n    spec = spec_lr,\n    recipe_lr\n    )\n\nwf_bana_wilt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: logistic_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n2 Recipe Steps\n\n• step_zv()\n• step_corr()\n\n── Model ───────────────────────────────────────────────────────────────────────\nLogistic Regression Model Specification (classification)\n\nComputational engine: glm \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n#### Fitting the logistic regression model\n\nNow we use the workflow previously created to fit the model on our training data. We use the training partition of the data.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_lr <- wf_bana_wilt  |> \n  fit(data = data_train)\n```\n:::\n\n\n\n\n\n\n\n\nLet's check the output:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_lr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: logistic_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n2 Recipe Steps\n\n• step_zv()\n• step_corr()\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:  stats::glm(formula = ..y ~ ., family = stats::binomial, data = data)\n\nCoefficients:\n(Intercept)     OBJECTID         ndvi         ndre         cire         sipi  \n    7.64191     -0.02527      4.33597     27.50498      3.19965     -0.11597  \n\nDegrees of Freedom: 59 Total (i.e. Null);  54 Residual\nNull Deviance:\t    83.18 \nResidual Deviance: 32.8 \tAIC: 44.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNow, we will use the fitted model to estimate health status in the training data:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_training_pred <- \n  predict(fit_lr, data_train) |> \n  bind_cols(predict(fit_lr, data_train, type = \"prob\")) |> \n  # Add the true outcome data back in\n  bind_cols(data_train |> \n              select(score))\n```\n:::\n\n\n\n\n\n\n\n\nWhat we got?\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_training_pred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n   .pred_class .pred_healthy .pred_wilted score  \n   <fct>               <dbl>        <dbl> <fct>  \n 1 healthy        0.992           0.00816 healthy\n 2 healthy        0.983           0.0169  healthy\n 3 wilted         0.378           0.622   wilted \n 4 healthy        0.988           0.0119  healthy\n 5 wilted         0.00000607      1.00    wilted \n 6 wilted         0.132           0.868   wilted \n 7 wilted         0.182           0.818   wilted \n 8 healthy        0.910           0.0905  wilted \n 9 healthy        0.966           0.0345  healthy\n10 wilted         0.0100          0.990   wilted \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLet's estimate the training accuracy:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_training_pred |> # training set predictions\n  accuracy(truth = score, .pred_class) -> acc_train\nacc_train\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary          0.85\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe accuracy of the model on the training data is 0.85 which is above 0.5 (mere chance). This basically means that the model was able to learn predictive patterns from the training data. To see if the model is able to generalize what it learned when exposed to new data, we evaluate the model on our hold-out (or so-called test data). We created a test dataset when splitting the data at the start of the modelling.\n\n#### Evaluating the model on test data\n\nNow, we will use the fitted model to estimate health status in the testing data:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_testing_pred <- \n  predict(fit_lr, data_test) |> \n  bind_cols(predict(fit_lr, data_test, type = \"prob\")) |> \n  bind_cols(data_test |> select(score))\n```\n:::\n\n\n\n\n\n\n\n\nWhat we got:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_testing_pred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 4\n   .pred_class .pred_healthy .pred_wilted score  \n   <fct>               <dbl>        <dbl> <fct>  \n 1 healthy          0.656       0.344     healthy\n 2 wilted           0.0587      0.941     healthy\n 3 healthy          0.870       0.130     healthy\n 4 wilted           0.251       0.749     healthy\n 5 healthy          1.00        0.0000730 healthy\n 6 wilted           0.0425      0.957     wilted \n 7 wilted           0.0171      0.983     wilted \n 8 wilted           0.000527    0.999     wilted \n 9 wilted           0.0207      0.979     wilted \n10 healthy          0.513       0.487     wilted \n11 wilted           0.00174     0.998     wilted \n12 wilted           0.0294      0.971     wilted \n13 wilted           0.0341      0.966     wilted \n14 wilted           0.414       0.586     healthy\n15 healthy          0.992       0.00792   healthy\n16 healthy          0.880       0.120     healthy\n17 healthy          0.999       0.00142   healthy\n18 healthy          0.976       0.0242    healthy\n19 wilted           0.112       0.888     wilted \n20 wilted           0.0713      0.929     wilted \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLet's compute the testing accuracy:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_testing_pred |>                   # test set predictions\n  accuracy(score, .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary           0.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe resulting accuracy is similar to the accuracy on the training data. It is good for a first go and a relatively simple classification model.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Let's plot the AUC-ROC \nlr_testing_pred |> \n  roc_curve(truth = score, .pred_wilted, event_level=\"second\") |> \n  mutate(model = \"Logistic Regression\") |>\n  autoplot()\n```\n\n::: {.cell-output-display}\n![](data-remote-sensing_files/figure-docx/unnamed-chunk-52-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n### Conclusions\n\nIn this section, we trained and tested a logistic regression model (LGM) using four spectral indices as predictor variables (i.e. NDVI, NDRE, CIRE and SIPI). Compare this section results, in terms of equation and accuracy, with the individual LGMs tested by [@ye2020][@fig-RS13].\n\n![](imgs/RS_logregmodels.png){#fig-RS13 fig-align=\"center\"}\n\nNote that we have not tested other ML algorithms. But there are a lot of them available from the *tidymodels* framework (e.g. random forests, support vector machines, gradient boosting machines).\n\nTo conclude, this section illustrated how to use VIs derived from UAV-based multispectral imagery and ground data to develop an identification model for detecting banana Fusarium wilt. The results showed that a simple logistic regression model is able to identify Fusarium wilt of banana from several VIs with a good accuracy. However, before going too optimistic, I would suggest to study the @ye2020 paper and critically evaluate their experiment design, methods and results.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}